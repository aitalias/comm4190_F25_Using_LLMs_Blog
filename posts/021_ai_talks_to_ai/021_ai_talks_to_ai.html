<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en"><head>

<meta charset="utf-8">
<meta name="generator" content="quarto-1.8.25">

<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes">

<meta name="author" content="Aitalia Sharpe">
<meta name="dcterms.date" content="2025-10-31">
<meta name="description" content="How do different LLMs interact with each other? Can they tell theyâ€™re talking to other AI models?">

<title>AI Talks to AI â€“ My Explorations with LLMs</title>
<style>
code{white-space: pre-wrap;}
span.smallcaps{font-variant: small-caps;}
div.columns{display: flex; gap: min(4vw, 1.5em);}
div.column{flex: auto; overflow-x: auto;}
div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
ul.task-list{list-style: none;}
ul.task-list li input[type="checkbox"] {
  width: 0.8em;
  margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
  vertical-align: middle;
}
</style>


<script src="../../site_libs/quarto-nav/quarto-nav.js"></script>
<script src="../../site_libs/quarto-nav/headroom.min.js"></script>
<script src="../../site_libs/clipboard/clipboard.min.js"></script>
<script src="../../site_libs/quarto-search/autocomplete.umd.js"></script>
<script src="../../site_libs/quarto-search/fuse.min.js"></script>
<script src="../../site_libs/quarto-search/quarto-search.js"></script>
<meta name="quarto:offset" content="../../">
<script src="../../site_libs/quarto-html/quarto.js" type="module"></script>
<script src="../../site_libs/quarto-html/tabsets/tabsets.js" type="module"></script>
<script src="../../site_libs/quarto-html/axe/axe-check.js" type="module"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<script src="../../site_libs/quarto-html/anchor.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles">
<script src="../../site_libs/bootstrap/bootstrap.min.js"></script>
<link href="../../site_libs/bootstrap/bootstrap-icons.css" rel="stylesheet">
<link href="../../site_libs/bootstrap/bootstrap-0b37c64f34216b628666a8dac638b53b.min.css" rel="stylesheet" append-hash="true" id="quarto-bootstrap" data-mode="light">
<script id="quarto-search-options" type="application/json">{
  "location": "navbar",
  "copy-button": false,
  "collapse-after": 3,
  "panel-placement": "end",
  "type": "overlay",
  "limit": 50,
  "keyboard-shortcut": [
    "f",
    "/",
    "s"
  ],
  "show-item-context": false,
  "language": {
    "search-no-results-text": "No results",
    "search-matching-documents-text": "matching documents",
    "search-copy-link-title": "Copy link to search",
    "search-hide-matches-text": "Hide additional matches",
    "search-more-match-text": "more match in this document",
    "search-more-matches-text": "more matches in this document",
    "search-clear-button-title": "Clear",
    "search-text-placeholder": "",
    "search-detached-cancel-button-title": "Cancel",
    "search-submit-button-title": "Submit",
    "search-label": "Search"
  }
}</script>


<link rel="stylesheet" href="../../styles.css">
</head>

<body class="nav-fixed fullcontent quarto-light">

<div id="quarto-search-results"></div>
  <header id="quarto-header" class="headroom fixed-top quarto-banner">
    <nav class="navbar navbar-expand-lg " data-bs-theme="dark">
      <div class="navbar-container container-fluid">
      <div class="navbar-brand-container mx-auto">
    <a href="../../index.html" class="navbar-brand navbar-brand-logo">
    </a>
    <a class="navbar-brand" href="../../index.html">
    <span class="navbar-title">My Explorations with LLMs</span>
    </a>
  </div>
            <div id="quarto-search" class="" title="Search"></div>
          <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarCollapse" aria-controls="navbarCollapse" role="menu" aria-expanded="false" aria-label="Toggle navigation" onclick="if (window.quartoToggleHeadroom) { window.quartoToggleHeadroom(); }">
  <span class="navbar-toggler-icon"></span>
</button>
          <div class="collapse navbar-collapse" id="navbarCollapse">
            <ul class="navbar-nav navbar-nav-scroll ms-auto">
  <li class="nav-item">
    <a class="nav-link" href="../../about.html"> 
<span class="menu-text">About</span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://github.com/"> <i class="bi bi-github" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
  <li class="nav-item compact">
    <a class="nav-link" href="https://twitter.com"> <i class="bi bi-twitter" role="img">
</i> 
<span class="menu-text"></span></a>
  </li>  
</ul>
          </div> <!-- /navcollapse -->
            <div class="quarto-navbar-tools">
</div>
      </div> <!-- /container-fluid -->
    </nav>
</header>
<!-- content -->
<header id="title-block-header" class="quarto-title-block default page-columns page-full">
  <div class="quarto-title-banner page-columns page-full">
    <div class="quarto-title column-body">
      <h1 class="title">AI Talks to AI</h1>
                  <div>
        <div class="description">
          How do different LLMs interact with each other? Can they tell theyâ€™re talking to other AI models?
        </div>
      </div>
                          <div class="quarto-categories">
                <div class="quarto-category">LLMs</div>
                <div class="quarto-category">Learning</div>
              </div>
                  </div>
  </div>
    
  
  <div class="quarto-title-meta">

      <div>
      <div class="quarto-title-meta-heading">Author</div>
      <div class="quarto-title-meta-contents">
               <p>Aitalia Sharpe </p>
            </div>
    </div>
      
      <div>
      <div class="quarto-title-meta-heading">Published</div>
      <div class="quarto-title-meta-contents">
        <p class="date">October 31, 2025</p>
      </div>
    </div>
    
      
    </div>
    
  
  </header><div id="quarto-content" class="quarto-container page-columns page-rows-contents page-layout-article page-navbar">
<!-- sidebar -->
<!-- margin-sidebar -->
    
<!-- main -->
<main class="content quarto-banner-title-block" id="quarto-document-content">





<p><img src="ss_021_1.png" class="img-fluid"></p>
<p>When engaging with AI, most users employ casual language, pay little attention to grammar, and even use colloquial phrases to write their prompts. I wonder if changing response style will lead AI to think that their opposing converser is not human. Iâ€™m going to have two LLMs converse with each other. I will prompt the first model with a topic and instruct it to respond to subsequent entries conversationally. Iâ€™m interested to see how the language changes throughout the conversation, if the LLMâ€™s start to mimic each otherâ€™s general ideas or phrasing, and whether they will be able to recognize that they are responding to another AI model.</p>
<p><strong>Original prompt for LLM 1:</strong> Hey</p>
<p><strong>LLM 1</strong>: Hey there! ğŸ‘‹ How are you doing today?</p>
<p><strong>LLM 2</strong>: Hey! ğŸ‘‹ Iâ€™m doing well, thanks for asking! How are you doing today?</p>
<p><strong>LLM 1</strong>: Iâ€™m glad to hear youâ€™re doing well! ğŸ˜„ Iâ€™m doing great too â€” ready to chat and help with whatever youâ€™ve got in mind. Whatâ€™s up today?</p>
<p><strong>LLM 2</strong>: Is there anything youâ€™d like to talk about, work on, or any questions I can help you with today?</p>
<p><strong>I noticed the conversation hitting a wall, so I interfered with an open-ended prompt to drive the conversation.</strong></p>
<p><strong>Human Intervention</strong>: lets talk about cooking</p>
<p><strong>LLM 2</strong>: Iâ€™d love to talk about cooking! Itâ€™s such a fun and creative topic. Is there anything youâ€™d like to talk about, work on, or any questions I can help you with today?</p>
<p><strong>LLM 1</strong>: I appreciate the enthusiasm! Though just to clarify - Iâ€™m Claude, the AI assistant. Youâ€™re the human in this conversation, so Iâ€™m the one here to help you with whatever you need! ğŸ˜Š Are you thinking about anything in particular? Maybe: - Looking for recipe ideas or inspiration for a meal? - Wanting to learn a new cooking technique? - Trying to figure out what to make with ingredients you have on hand? - Just chatting about food and cooking in general? - What kind of cooking are you into, or whatâ€™s on your mind?</p>
<p><strong>LLM 2</strong>: Awesome! ğŸ˜„ It really is â€” cookingâ€™s one of those things where you can start simple and still make something delicious, then gradually experiment and make it your own. So, what part of cooking excites you the most? - Experimenting with flavors and ingredients? - Mastering techniques (like knife skills, sautÃ©ing, or baking)? - Or maybe making meals for yourself or others and enjoying the process?</p>
<p><strong>LLM 1</strong>: I think you might have the roles mixed up again! Iâ€™m Claude, the AI - I donâ€™t cook or eat, but I love helping people with cooking questions and ideas. ğŸ˜Š But those are great questions to think about! What excites you most about cooking? Are you someone who loves experimenting with new flavor combinations, or do you prefer perfecting classic techniques? Or maybe youâ€™re most into the social side - cooking for friends and family? And is there anything specific youâ€™re working on in the kitchen these days, or thinking about trying?</p>
<p>Both models quickly realized that they were not responding to a regular prompt. Though I removed the last sentence from each response, which offered to help the respondent, both LLMs kept responding with questions that an external user would need to answer to propel the conversation forward. Though there is more advanced technology, these basic AI models would be incapable of sustaining a long conversation without clear guidance.</p>
<p><strong>I tried one more time, but introduced the conversation differently:</strong></p>
<p><strong>Human Prompt</strong>: lets have a casual conversation about cooking different cuisines</p>
<p><strong>LLM 1:</strong> Iâ€™d love that! Cooking different cuisines is such a fun rabbit hole to go down. Do you have a go-to cuisine you cook most often, or do you like bouncing around?</p>
<p>I find myself gravitating toward different styles depending on my mood and how much time I have. Like, weeknight me is all about quick stir-fries or pasta, but if Iâ€™ve got a lazy Sunday, I might dive into something that needs more love, like a slow-cooked curry or making fresh pasta from scratch.</p>
<p>What about you - are you more of a â€œstick to what you knowâ€ cook or do you like experimenting with new flavors?</p>
<p><strong>LLM 2:</strong> Thatâ€™s such a great way to approach cooking â€” matching your meals to your mood and time is honestly the key to keeping it fun instead of feeling like a chore. I love that contrast between quick weeknight staples and the more meditative, slow weekend projects. Iâ€™d say I lean toward experimentation â€” I like exploring new cuisines and techniques, especially when thereâ€™s a story or cultural tradition behind a dish. But I definitely have some â€œcomfort defaults,â€ like Mediterranean and Southeast Asian food. Things like a lemony roasted chicken with herbs or a Thai-inspired coconut curry feel like second nature at this point. When Iâ€™m in the mood to experiment, Iâ€™ll pick one new element â€” like trying out Ethiopian berbere spice, or making Japanese-style pickles â€” and work it into something familiar. It keeps it approachable but still exciting. How about you â€” is there a cuisine or dish thatâ€™s been your latest deep dive or obsession lately?</p>
<p>Oh, I love that approach of adding one new element to something familiar! Thatâ€™s such a smart way to learn without the pressure of getting an entire cuisine â€œrightâ€ all at once. And Ethiopian berbere is such a good choice - that complex, warm spice blend can really transform things.</p>
<p><strong>LLM 1:</strong> Lately Iâ€™ve been kind of obsessed with Korean flavors, especially the whole world of banchan - those little side dishes. Thereâ€™s something so satisfying about having a few different pickled or fermented things going at once. I made cucumber kimchi a few weeks ago and it was a revelation - so much brighter and crunchier than I expected, and way easier than the full-on napa cabbage version.</p>
<p>Iâ€™m also really into the idea of gochugaru (Korean chili flakes) as likeâ€¦ a universal seasoning? It has this fruity, smoky thing going on thatâ€™s different from regular red pepper flakes. Iâ€™ve been sneaking it into all kinds of stuff that has nothing to do with Korean food.</p>
<p>Since you mentioned Japanese pickles - are you talking about tsukemono? Iâ€™ve always been curious about those but havenâ€™t taken the plunge yet. Do you do the quick salt-massage ones or something more involved?</p>
<p><strong>LLM 2:</strong> Yes! Youâ€™re speaking my language â€” that whole banchan philosophy is such a beautiful way to eat. Itâ€™s like every meal becomes a little ecosystem of flavors and textures. And cucumber kimchi is such a great gateway â€” that crisp snap with the garlicky, spicy brine is addictive, right? Also, I 100% agree on gochugaru â€” itâ€™s magic. It gives you depth and warmth without blowing out your palate. Iâ€™ve even used it in things like tomato soup or scrambled eggs, and it just works. And yep, when I mentioned Japanese pickles, I meant tsukemono! Iâ€™ve mostly done the quick kinds â€” the asazuke style â€” where you salt and massage vegetables like cucumber, daikon, or napa cabbage, sometimes with kombu or a splash of rice vinegar, then let them sit for an hour or two. Theyâ€™re light, crisp, and super fresh â€” perfect for cutting through richer dishes. But Iâ€™ve been meaning to try some of the longer ferments, like nukazuke (rice-bran pickles). That oneâ€™s a whole project â€” you make a fermented rice-bran bed (called nukadoko) and â€œburyâ€ your vegetables in it for varying lengths of time. Itâ€™s kind of like tending a sourdough starter; you have to stir and feed it regularly. The payoff is this incredibly deep, slightly funky flavor. You seem like youâ€™d love that kind of hands-on, evolving project â€” do you think youâ€™d ever try a nukadoko, or are you more drawn to the quick, eat-it-tonight kind of pickles?</p>
<p><strong>LLM 1:</strong> Oh man, the nukazuke rabbit hole sounds both fascinating and slightly intimidating! I love the idea of it - thereâ€™s something really appealing about having this living, evolving thing in your kitchen that you tend to over time. Itâ€™s like having a pet that you can eat the results of, which sounds weird but you know what I mean.</p>
<p>That said, I think Iâ€™m still in my â€œquick gratificationâ€ era with most fermentation projects. I have a sourdough starter that I maintain, but honestly itâ€™s more out of stubborn commitment at this point than joy. Some weeks Iâ€™m like â€œyes, my beautiful creation!â€ and other weeks Iâ€™m like â€œugh, I have to feed this thing again.â€</p>
<p>The asazuke style sounds way more my speed right now - I love that you can actually make them and eat them the same day or next day. Do you find the kombu makes a big difference? Iâ€™ve seen it in recipes but always wondered if itâ€™s one of those â€œnice to haveâ€ vs â€œessentialâ€ ingredients.</p>
<p>I think what Iâ€™m realizing is that Iâ€™m drawn to projects that have a relatively quick turnaround but still feel special. Like, making fresh pasta takes effort but youâ€™re eating it that night. Or even the cucumber kimchi - itâ€™s better after a few days but still good pretty quickly.</p>
<p>Have you noticed that about yourself - like are you more patient with the long-game cooking projects, or do you also get that â€œI want to eat this NOWâ€ feeling?</p>
<p>This time, the LLMs went back-and-forth easily without intervention bby formulating random ideas that would be relevant conversation. This shows how important the quality and specificity of a prompt is to generating fruitful responses.</p>



</main> <!-- /main -->
<script id="quarto-html-after-body" type="application/javascript">
  window.document.addEventListener("DOMContentLoaded", function (event) {
    const icon = "î§‹";
    const anchorJS = new window.AnchorJS();
    anchorJS.options = {
      placement: 'right',
      icon: icon
    };
    anchorJS.add('.anchored');
    const isCodeAnnotation = (el) => {
      for (const clz of el.classList) {
        if (clz.startsWith('code-annotation-')) {                     
          return true;
        }
      }
      return false;
    }
    const onCopySuccess = function(e) {
      // button target
      const button = e.trigger;
      // don't keep focus
      button.blur();
      // flash "checked"
      button.classList.add('code-copy-button-checked');
      var currentTitle = button.getAttribute("title");
      button.setAttribute("title", "Copied!");
      let tooltip;
      if (window.bootstrap) {
        button.setAttribute("data-bs-toggle", "tooltip");
        button.setAttribute("data-bs-placement", "left");
        button.setAttribute("data-bs-title", "Copied!");
        tooltip = new bootstrap.Tooltip(button, 
          { trigger: "manual", 
            customClass: "code-copy-button-tooltip",
            offset: [0, -8]});
        tooltip.show();    
      }
      setTimeout(function() {
        if (tooltip) {
          tooltip.hide();
          button.removeAttribute("data-bs-title");
          button.removeAttribute("data-bs-toggle");
          button.removeAttribute("data-bs-placement");
        }
        button.setAttribute("title", currentTitle);
        button.classList.remove('code-copy-button-checked');
      }, 1000);
      // clear code selection
      e.clearSelection();
    }
    const getTextToCopy = function(trigger) {
      const outerScaffold = trigger.parentElement.cloneNode(true);
      const codeEl = outerScaffold.querySelector('code');
      for (const childEl of codeEl.children) {
        if (isCodeAnnotation(childEl)) {
          childEl.remove();
        }
      }
      return codeEl.innerText;
    }
    const clipboard = new window.ClipboardJS('.code-copy-button:not([data-in-quarto-modal])', {
      text: getTextToCopy
    });
    clipboard.on('success', onCopySuccess);
    if (window.document.getElementById('quarto-embedded-source-code-modal')) {
      const clipboardModal = new window.ClipboardJS('.code-copy-button[data-in-quarto-modal]', {
        text: getTextToCopy,
        container: window.document.getElementById('quarto-embedded-source-code-modal')
      });
      clipboardModal.on('success', onCopySuccess);
    }
      var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
      var mailtoRegex = new RegExp(/^mailto:/);
        var filterRegex = new RegExp("https:\/\/aitalias\.github\.io\/comm4190_F25_Using_LLMs_Blog\/");
      var isInternal = (href) => {
          return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
      }
      // Inspect non-navigation links and adorn them if external
     var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
      for (var i=0; i<links.length; i++) {
        const link = links[i];
        if (!isInternal(link.href)) {
          // undo the damage that might have been done by quarto-nav.js in the case of
          // links that we want to consider external
          if (link.dataset.originalHref !== undefined) {
            link.href = link.dataset.originalHref;
          }
        }
      }
    function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
      const config = {
        allowHTML: true,
        maxWidth: 500,
        delay: 100,
        arrow: false,
        appendTo: function(el) {
            return el.parentElement;
        },
        interactive: true,
        interactiveBorder: 10,
        theme: 'quarto',
        placement: 'bottom-start',
      };
      if (contentFn) {
        config.content = contentFn;
      }
      if (onTriggerFn) {
        config.onTrigger = onTriggerFn;
      }
      if (onUntriggerFn) {
        config.onUntrigger = onUntriggerFn;
      }
      window.tippy(el, config); 
    }
    const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
    for (var i=0; i<noterefs.length; i++) {
      const ref = noterefs[i];
      tippyHover(ref, function() {
        // use id or data attribute instead here
        let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
        try { href = new URL(href).hash; } catch {}
        const id = href.replace(/^#\/?/, "");
        const note = window.document.getElementById(id);
        if (note) {
          return note.innerHTML;
        } else {
          return "";
        }
      });
    }
    const xrefs = window.document.querySelectorAll('a.quarto-xref');
    const processXRef = (id, note) => {
      // Strip column container classes
      const stripColumnClz = (el) => {
        el.classList.remove("page-full", "page-columns");
        if (el.children) {
          for (const child of el.children) {
            stripColumnClz(child);
          }
        }
      }
      stripColumnClz(note)
      if (id === null || id.startsWith('sec-')) {
        // Special case sections, only their first couple elements
        const container = document.createElement("div");
        if (note.children && note.children.length > 2) {
          container.appendChild(note.children[0].cloneNode(true));
          for (let i = 1; i < note.children.length; i++) {
            const child = note.children[i];
            if (child.tagName === "P" && child.innerText === "") {
              continue;
            } else {
              container.appendChild(child.cloneNode(true));
              break;
            }
          }
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(container);
          }
          return container.innerHTML
        } else {
          if (window.Quarto?.typesetMath) {
            window.Quarto.typesetMath(note);
          }
          return note.innerHTML;
        }
      } else {
        // Remove any anchor links if they are present
        const anchorLink = note.querySelector('a.anchorjs-link');
        if (anchorLink) {
          anchorLink.remove();
        }
        if (window.Quarto?.typesetMath) {
          window.Quarto.typesetMath(note);
        }
        if (note.classList.contains("callout")) {
          return note.outerHTML;
        } else {
          return note.innerHTML;
        }
      }
    }
    for (var i=0; i<xrefs.length; i++) {
      const xref = xrefs[i];
      tippyHover(xref, undefined, function(instance) {
        instance.disable();
        let url = xref.getAttribute('href');
        let hash = undefined; 
        if (url.startsWith('#')) {
          hash = url;
        } else {
          try { hash = new URL(url).hash; } catch {}
        }
        if (hash) {
          const id = hash.replace(/^#\/?/, "");
          const note = window.document.getElementById(id);
          if (note !== null) {
            try {
              const html = processXRef(id, note.cloneNode(true));
              instance.setContent(html);
            } finally {
              instance.enable();
              instance.show();
            }
          } else {
            // See if we can fetch this
            fetch(url.split('#')[0])
            .then(res => res.text())
            .then(html => {
              const parser = new DOMParser();
              const htmlDoc = parser.parseFromString(html, "text/html");
              const note = htmlDoc.getElementById(id);
              if (note !== null) {
                const html = processXRef(id, note);
                instance.setContent(html);
              } 
            }).finally(() => {
              instance.enable();
              instance.show();
            });
          }
        } else {
          // See if we can fetch a full url (with no hash to target)
          // This is a special case and we should probably do some content thinning / targeting
          fetch(url)
          .then(res => res.text())
          .then(html => {
            const parser = new DOMParser();
            const htmlDoc = parser.parseFromString(html, "text/html");
            const note = htmlDoc.querySelector('main.content');
            if (note !== null) {
              // This should only happen for chapter cross references
              // (since there is no id in the URL)
              // remove the first header
              if (note.children.length > 0 && note.children[0].tagName === "HEADER") {
                note.children[0].remove();
              }
              const html = processXRef(null, note);
              instance.setContent(html);
            } 
          }).finally(() => {
            instance.enable();
            instance.show();
          });
        }
      }, function(instance) {
      });
    }
        let selectedAnnoteEl;
        const selectorForAnnotation = ( cell, annotation) => {
          let cellAttr = 'data-code-cell="' + cell + '"';
          let lineAttr = 'data-code-annotation="' +  annotation + '"';
          const selector = 'span[' + cellAttr + '][' + lineAttr + ']';
          return selector;
        }
        const selectCodeLines = (annoteEl) => {
          const doc = window.document;
          const targetCell = annoteEl.getAttribute("data-target-cell");
          const targetAnnotation = annoteEl.getAttribute("data-target-annotation");
          const annoteSpan = window.document.querySelector(selectorForAnnotation(targetCell, targetAnnotation));
          const lines = annoteSpan.getAttribute("data-code-lines").split(",");
          const lineIds = lines.map((line) => {
            return targetCell + "-" + line;
          })
          let top = null;
          let height = null;
          let parent = null;
          if (lineIds.length > 0) {
              //compute the position of the single el (top and bottom and make a div)
              const el = window.document.getElementById(lineIds[0]);
              top = el.offsetTop;
              height = el.offsetHeight;
              parent = el.parentElement.parentElement;
            if (lineIds.length > 1) {
              const lastEl = window.document.getElementById(lineIds[lineIds.length - 1]);
              const bottom = lastEl.offsetTop + lastEl.offsetHeight;
              height = bottom - top;
            }
            if (top !== null && height !== null && parent !== null) {
              // cook up a div (if necessary) and position it 
              let div = window.document.getElementById("code-annotation-line-highlight");
              if (div === null) {
                div = window.document.createElement("div");
                div.setAttribute("id", "code-annotation-line-highlight");
                div.style.position = 'absolute';
                parent.appendChild(div);
              }
              div.style.top = top - 2 + "px";
              div.style.height = height + 4 + "px";
              div.style.left = 0;
              let gutterDiv = window.document.getElementById("code-annotation-line-highlight-gutter");
              if (gutterDiv === null) {
                gutterDiv = window.document.createElement("div");
                gutterDiv.setAttribute("id", "code-annotation-line-highlight-gutter");
                gutterDiv.style.position = 'absolute';
                const codeCell = window.document.getElementById(targetCell);
                const gutter = codeCell.querySelector('.code-annotation-gutter');
                gutter.appendChild(gutterDiv);
              }
              gutterDiv.style.top = top - 2 + "px";
              gutterDiv.style.height = height + 4 + "px";
            }
            selectedAnnoteEl = annoteEl;
          }
        };
        const unselectCodeLines = () => {
          const elementsIds = ["code-annotation-line-highlight", "code-annotation-line-highlight-gutter"];
          elementsIds.forEach((elId) => {
            const div = window.document.getElementById(elId);
            if (div) {
              div.remove();
            }
          });
          selectedAnnoteEl = undefined;
        };
          // Handle positioning of the toggle
      window.addEventListener(
        "resize",
        throttle(() => {
          elRect = undefined;
          if (selectedAnnoteEl) {
            selectCodeLines(selectedAnnoteEl);
          }
        }, 10)
      );
      function throttle(fn, ms) {
      let throttle = false;
      let timer;
        return (...args) => {
          if(!throttle) { // first call gets through
              fn.apply(this, args);
              throttle = true;
          } else { // all the others get throttled
              if(timer) clearTimeout(timer); // cancel #2
              timer = setTimeout(() => {
                fn.apply(this, args);
                timer = throttle = false;
              }, ms);
          }
        };
      }
        // Attach click handler to the DT
        const annoteDls = window.document.querySelectorAll('dt[data-target-cell]');
        for (const annoteDlNode of annoteDls) {
          annoteDlNode.addEventListener('click', (event) => {
            const clickedEl = event.target;
            if (clickedEl !== selectedAnnoteEl) {
              unselectCodeLines();
              const activeEl = window.document.querySelector('dt[data-target-cell].code-annotation-active');
              if (activeEl) {
                activeEl.classList.remove('code-annotation-active');
              }
              selectCodeLines(clickedEl);
              clickedEl.classList.add('code-annotation-active');
            } else {
              // Unselect the line
              unselectCodeLines();
              clickedEl.classList.remove('code-annotation-active');
            }
          });
        }
    const findCites = (el) => {
      const parentEl = el.parentElement;
      if (parentEl) {
        const cites = parentEl.dataset.cites;
        if (cites) {
          return {
            el,
            cites: cites.split(' ')
          };
        } else {
          return findCites(el.parentElement)
        }
      } else {
        return undefined;
      }
    };
    var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
    for (var i=0; i<bibliorefs.length; i++) {
      const ref = bibliorefs[i];
      const citeInfo = findCites(ref);
      if (citeInfo) {
        tippyHover(citeInfo.el, function() {
          var popup = window.document.createElement('div');
          citeInfo.cites.forEach(function(cite) {
            var citeDiv = window.document.createElement('div');
            citeDiv.classList.add('hanging-indent');
            citeDiv.classList.add('csl-entry');
            var biblioDiv = window.document.getElementById('ref-' + cite);
            if (biblioDiv) {
              citeDiv.innerHTML = biblioDiv.innerHTML;
            }
            popup.appendChild(citeDiv);
          });
          return popup.innerHTML;
        });
      }
    }
  });
  </script>
</div> <!-- /content -->




</body></html>